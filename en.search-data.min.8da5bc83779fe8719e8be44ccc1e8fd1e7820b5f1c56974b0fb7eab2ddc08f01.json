[{"id":0,"href":"/post/cpp-attributes/","title":"Attributes in C/C++","section":"Posts","content":" __attribute__ # In C/C++, one can apply an attribute to a function or a variable using a keyword __attribute__.\nWhile it is not part of ISO C standard, popular compilers such as Clang and GCC support it. So, an attribute supported by these two compilers need not be modified.\n[[attribute]] # There is another syntax for attributes that is introduced since C23 and C++11, which is [[attribute]].\nAttribute Namespace # Unlike __attribute__, this syntax requires a namespace to be specified for non-standard attributes as below:\n[[gnu::nodiscard]] int func1() { return 0; } GCC stores its attributes under the namespace called gnu. This is shown in its source code:\n/* Put all the GNU attributes into the \u0026#34;gnu\u0026#34; namespace. */ register_scoped_attributes (attribute_tables[i], \u0026#34;gnu\u0026#34;); It seems like Clang uses both its own namespace and GCC\u0026rsquo;s.\nAs shown in this live demo, Clang accepts [[gnu::noinline]] while it rejects [[clang::noinline]].\nNote that there is a new syntax for an attribute namespace since C++17.\nCaveat # When [[attribute]] is applied to a function, it can be specified either before the return type or after the function name as below:\n[[nodiscard]] int func1() { return 0; } int [[nodiscard]] func2() { return 0; } // invalid int func3 [[nodiscard]] () { return 0; } int func4 () [[nodiscard]] { return 0; } // invalid Live demo\nAs shown in the above live demo, GCC 11.2 accepts the code though it emits errors while Clang 13 rejects it.\nAn attribute to a lambda was introduced in C++23, and it can only be specified in one location:\nint i = [] [[nodiscard]] { return 0; }(); Live demo\nGCC with -std=c++20 accepts the code without a warning while Clang with -std=c++20 accepts the code with a warning.\n"},{"id":1,"href":"/post/static-variables-and-undefined-behaviors-in-cpp/","title":"Static Objects and Undefined Behaviors in C++","section":"Posts","content":" Definition of static objects # Let me start this article with the definition of static objects.\nA static object refers to a object with a static storage duration. Specifically, it is unique by existence and will exist throughout the execution of a program.\nstatic objects in practice # Then, what are static objects in C++?\nThere are mainly two types of static objects: those with internal linkage and the other with external linkage.\nThe former is only accessible inside a single translation unit. A translation unit refers to source code compiled into a single object file. The latter, however, can be exported to other translation units.\nObjects declared at a namespace scope # This holds an external linkage.\nint var1; extern int var2; namespace hyundeok { int var1; extern int var2; } One can access this object with a scope resolution operator (::) as below:\nint foo1() { return ++var1; } int foo2() { return ++hyundeok::var1; } Note that objects at a global scope where they do not belong to any explicit namespace are also part of namespace. That said, a global scope is known as a global namespace and one can access its objects by specifying a scope resolution operator (::) without any namespace.\nint var; void func() { // without a scope resolution operator ++var; // with a scope resolution operator ++::var; } There are several cases when these objects have an internal linkage:\nPer [basic.link/3],\nThe name of an entity that belongs to a namespace scope has internal linkage if it is the name of\na variable, variable template, function, or function template that is explicitly declared static; or a non-template variable of non-volatile const-qualified type, unless it is explicitly declared extern, or it is inline or exported, or it was previously declared and the prior declaration did not have internal linkage; or a data member of an anonymous union. This is linked with the next case for static objects.\nObjects declared static # This one is a bit tricky.\nThe static keyword have different meanings depending on the context. The static keyword can specify either static storage duration or whether a class member is bound to class instances. In short, not all objects declared with the static keyword have an internal linkage.\nObjects declared static can be categorized into three cases.\n1. Those declared inside classes # Classes and their members have no linkage. As mentioned above, static here means that a member is the same across the instances of a class.\nclass Foo { public: static int var; }; One can access this object with a dot operator (.) or a scope resolution operator (::) as below:\nint Foo::var = 42; void access_foo_var() { ++Foo::var; } int main() { Foo foo; // dot operator foo.var; // 42 // scope resolution operator Foo::var; // 42 } Note that static class data members need to be defined at a file scope before use.\nThere are exceptions to this when static data members are declared:\ninline (C++17); or const or constexpr and are initialized [class.static/data-4] discusses this in more detail.\n2. Those declared inside functions # These are also called static local variables and have an internal linkage. They are useful to make a singleton pattern:\nint\u0026amp; get_instance() { static int i; return i; } The variable i is initialized only once. The return value of get_instance always refers to the same i.\n3. Those declared at a file scope # These static objects have an internal linkage; hence, they cannot be exported via extern either.\nstatic int var; Undefined behaviors of static objects # Now, let\u0026rsquo;s talk about undefined behaviors, or UB.\nOne can access static objects to call functions or initialze variables in other files as below:\nA file named foo.h has a variable var1 at a global namespace, which is initialized with a function call:\n// foo.h int var1 = db.get_no(); A file named bar.h exports var1 in foo.h to initialize another variable var2:\n// bar.h extern int var1; int var2 = var1 * 1.13; The result of this is undefined since there is no guarantee that var1 is initialized before var2. The C++ standard does not specify in which order static objects are initialized.\nSolution # Use local static variables, which are static objects declared inside functions.\n// foo.h int\u0026amp; get_db_no { static int var1 = db.get_no(); return var1; } Call the function in another file.\n// bar.h #include foo.h int var2 = get_db_no() * 1.13; "},{"id":2,"href":"/post/my-first-post/","title":"My First Post","section":"Posts","content":"Hello, this is my first post on GitHub blog.\nThis site is powered by Hugo, a static site generator.\nHere is an example $$ \\LaTeX $$ code to test whether it works on Markdown:\n$$ \\begin{align*} f(x) \u0026amp;= x^2\\ g(x) \u0026amp;= \\frac{1}{x}\\ F(x) \u0026amp;= \\int^a_b \\frac{1}{3}x^3 \\end{align*} $$\nKaTeX is the $$ \\LaTeX $$ rendering engine used for my blog.\n"}]